---
AWSTemplateFormatVersion: 2010-09-09
Description: '**WARNING** This template creates Amazon EventBridge Scheduler task, Lambda
  Functions, CloudWatch Logs subscription filter, SNS Topic, EC2 resources and related resources. You will be billed for the AWS resources
  used if you create a stack from this template.'
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: On Demand Malware Scan Sample Tester - Amazon EC2 Configuration
        Parameters:
          - CreateMalwareTester
          - LatestLinuxAMI
          - TagKey
          - TagValue
      - Label:
          default: Scheduled Malware Scan Parameters
        Parameters:
          - Organizations
          - AccountIDs
          - TagKeyValues
          - EC2InstancesByID
          - InstanceState
      - Label:
          default: AWS Scheduler Parameters
        Parameters:
          - ScheduleRate
          - ScheduleStartDate
          - ScheduleTimeZone
      - Label:
          default: AWS Config Parameters
        Parameters:
          - ConfigAggregator
          - ConfigAggregatorRegion

    ParameterLabels:
      CreateMalwareTester:
        default: Create On Demand Malware Scan Sample Tester Condition
      LatestLinuxAMI:
        default: Latest Amazon Linux Instance used for Tester
      TagKeyValues:
        default: Tag Keys/Values parameter
      EC2InstancesByID:
        default: EC2 Instances IDs to be scan
      InstanceState:
        default: EC2 Instances State
      ScheduleRate:
        default: Rate for the schedule scan to be run
      ScheduleStartDate:
        default: First time scheduled scan will run
      ScheduleTimeZone:
        default: Time Zone
      TagKey:
        default: 'Tag Key'
      TagValue:
        default: 'Tag Value'
      ConfigAggregator:
        default: Config Aggregator Name
      ConfigAggregatorRegion:
        default: Config Aggregator Region 
      Organizations:
        default: Organizations parameter
      AccountIDs:
        default: Account ID values parameter

Parameters:
  CreateMalwareTester:
    Description: "'True' will generate On Demand Malware Scan Sample Tester resources. 'False' will skipped them"
    Type: String
    Default: "False"
    AllowedValues:
      - "True"
      - "False"
  ScheduleRate:
    Type: String
    Description: Input the schedule rate e.g. days, weeks, minutes, hours.
    Default: "rate(7 days)"
  ScheduleStartDate:
    Type: String
    Description: Input a date in UTC format, related to Time Zone parameter. NOTE this value is required to be set after current time
    Default: "2024-06-26T18:40:00.000Z"
  ScheduleTimeZone:
    Type: String
    Description: Input a valid zone value, for reference - https://docs.aws.amazon.com/scheduler/latest/UserGuide/schedule-types.html#time-zones
    Default: "Europe/Madrid"
  TagKeyValues:
    Type: String
    Description: 'Input the tag key values as a dictionary format and use double quotes e.g.{"TagKey": "TagValue"}, {"TagKey2": "TagValue2"}, {"TagKey3": "TagValue3"}'
    Default: '{"Name": "test1"}, {"Name": "test2"}, {"Name": "test3"}'
  InstanceState:
    Type: String
    Description: Select 'RUNNING' to scan EC2 instances in state 'running' or, 'STOPPED' to scan EC2 instances in states 'stopping', 'stopped', or 'BOTH' to scan EC2 instances in all previous mentioned states 
    Default: "RUNNING"
    AllowedValues:
      - "RUNNING"
      - "STOPPED"
      - "BOTH"
  TagKey:
    Type: String
    Description: 'Input the tag key for the On Demand Malware test instances'
  TagValue:
    Type: String
    Description: 'Input the tag value for the On Demand Malware test instances'
  LatestLinuxAMI:
    Type: 'AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>'
    Default: /aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2
  ConfigAggregator:
    Type: String
    Description: Input the Aggregator name
  ConfigAggregatorRegion:
    Type: String
    Description: Input the Aggregator Region
    Default: "us-east-1"
    AllowedValues:
      - "us-east-1"
      - "us-east-2"
      - "us-west-1"
      - "us-west-2"
      - "af-south-1"
      - "ap-east-1"
      - "ap-south-2"
      - "ap-southeast-3"
      - "ap-southeast-4"
      - "ap-south-1"
      - "ap-northeast-3"
      - "ap-northeast-2"
      - "ap-southeast-1"
      - "ap-southeast-2"
      - "ap-northeast-1"
      - "ca-central-1"
      - "eu-central-1"
      - "eu-west-1"
      - "eu-west-2"
      - "eu-south-1"
      - "eu-west-3"
      - "eu-south-2"
      - "eu-north-1"
      - "eu-central-2"
      - "il-central-1"
      - "me-south-1"
      - "me-central-1"
      - "sa-east-1"
      - "ca-west-1"
  Organizations:
    Type: String
    Description: Input "true" if scans should be performed acrross all your accounts in Organizations
    Default: "true"
    AllowedValues:
      - "true"
      - "false"
  AccountIDs:
    Type: String
    Description: If you set the Organizations Parameter to false only, insert accounts IDs separated by comma where to scan your resources e.g. accountID1,accountID2, accountID3
  EC2InstancesByID:
    Type: String
    Description: Input a list of EC2 Instance IDs to be scanned in addition to the tag based ones. Each ID separated by a comma e.g. InstanceID1,InstanceID2,InstanceID3
    Default: "i-0a04cf451bcdd4766, i-0c3c20156d141816c"

Conditions:
  IsTrue: !Equals [!Ref CreateMalwareTester, 'True']

Resources:
  VPC:
    Type: AWS::EC2::VPC
    Condition: IsTrue
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsSupport: true
      EnableDnsHostnames: true
      InstanceTenancy: default
      Tags:
        - Key: Name
          Value: On Demand Malware Scan Sample Tester
  
  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Condition: IsTrue
    Properties:
      Tags:
      - Key: Name
        Value: On Demand Malware Scan Sample Tester

  InternetGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Condition: IsTrue
    Properties:
      VpcId: !Ref VPC
      InternetGatewayId: !Ref InternetGateway

  PublicSubnet:
    Type: AWS::EC2::Subnet
    Condition: IsTrue
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.0.0/24
      Tags:
      - Key: Name
        Value: Public Subnet On Demand Malware Scan Sample Tester

  PrivateSubnet:
    Type: AWS::EC2::Subnet
    Condition: IsTrue
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.1.0/24
      Tags:
      - Key: Name
        Value: Private Subnet On Demand Malware Scan Sample Tester

  PublicRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Condition: IsTrue
    Properties:
      SubnetId: !Ref PublicSubnet
      RouteTableId: !Ref PublicRouteTable

  PrivateRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Condition: IsTrue
    Properties:
      SubnetId: !Ref PrivateSubnet
      RouteTableId: !Ref PrivateRouteTable

  NatGatewayEIP:
    Type: AWS::EC2::EIP
    Condition: IsTrue
    Properties:
      Domain: vpc
      Tags:
      - Key: Name
        Value: On Demand Malware Scan Sample Tester

  NatGateway:
    Type: AWS::EC2::NatGateway
    Condition: IsTrue
    Properties:
      AllocationId: !GetAtt NatGatewayEIP.AllocationId
      SubnetId: !Ref PublicSubnet
      Tags:
      - Key: Name
        Value: On Demand Malware Scan Sample Tester

  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Condition: IsTrue
    Properties:
      VpcId: !Ref VPC
      Tags:
      - Key: Name
        Value: Public

  PublicRoute:
    Type: AWS::EC2::Route
    Condition: IsTrue
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway

  PrivateRouteTable:
    Type: AWS::EC2::RouteTable
    Condition: IsTrue
    Properties:
      VpcId: !Ref VPC
      Tags:
      - Key: Name
        Value: Private

  PrivateRoute:
    Type: AWS::EC2::Route
    Condition: IsTrue
    Properties:
      RouteTableId: !Ref PrivateRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !GetAtt NatGateway.NatGatewayId

  NatInstanceSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Condition: IsTrue
    Properties:
      GroupDescription: Security group for NAT instance
      VpcId: !Ref VPC
      SecurityGroupEgress:
        - 
          Description: Egress Rule for for NAT instance
          IpProtocol: -1
          CidrIp: 0.0.0.0/0
      Tags:
      - Key: Name
        Value: NAT On Demand Malware Scan Sample Tester

  PrivateInstanceSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Condition: IsTrue
    Properties:
      GroupDescription: Security group for private instance
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - 
          Description: Ingress Rule for for private instance
          IpProtocol: -1
          SourceSecurityGroupId: !Ref NatInstanceSecurityGroup
      SecurityGroupEgress:
        - 
          Description: Egress Rule for for private instance
          IpProtocol: -1
          CidrIp: 0.0.0.0/0
      Tags:
      - Key: Name
        Value: Private Instance On Demand Malware Scan Sample Tester

  InstanceMalwareEicarSample:
    Type: 'AWS::EC2::Instance'
    Condition: IsTrue
    Properties:
      ImageId: !Ref LatestLinuxAMI
      InstanceType: t3.micro
      SubnetId: !Ref PrivateSubnet
      SecurityGroupIds:
        - Ref: PrivateInstanceSecurityGroup
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          yum install -y wget  # Install wget
          wget -O /home/ec2-user/eicar.com.txt https://secure.eicar.org/eicar.com.txt
          chown ec2-user:ec2-user /home/ec2-user/eicar.com.txt
      Tags:
        - Key: Name
          Value: OnDemandMalwareEicarSample
        - Key: !Ref TagKey
          Value: !Ref TagValue

  InstanceMalwareClean:
    Type: 'AWS::EC2::Instance'
    Condition: IsTrue
    Properties:
      ImageId: !Ref LatestLinuxAMI
      InstanceType: t3.micro
      SubnetId: !Ref PrivateSubnet
      SecurityGroupIds:
        - !Ref PrivateInstanceSecurityGroup
      Tags:
        - Key: Name
          Value: OnDemandMalwareClean
        - Key: !Ref TagKey
          Value: !Ref TagValue

  GuardDutyMalwareOnDemandScheduledEvent:
    Type: AWS::Scheduler::Schedule
    Properties: 
      Description: "Event scheduled to perform GuardDuty On Demand Malware Scans"
      FlexibleTimeWindow: 
        Mode: "OFF"
      Name: GuardDutyMalwareOnDemandScheduledEvent
      ScheduleExpression: !Ref ScheduleRate
      StartDate: !Ref ScheduleStartDate
      State: ENABLED
      ScheduleExpressionTimezone: !Ref ScheduleTimeZone
      Target: 
        RetryPolicy:
          MaximumEventAgeInSeconds: 60.0
          MaximumRetryAttempts: 00.0
        RoleArn: !GetAtt GuardDutyMalwareOnDemandScanSchedulerRole.Arn
        Arn: !GetAtt GuardDutyMalwareOnDemandScanScheduledLambdaFunction.Arn
        Input:
          Fn::Sub:
            - |
              { "Organizations": "${Organizations}",
                "AccountIDs": "${AccountIDs}",
                "EC2InstancesID": "${EC2InstancesByID}",
                "InstanceState": "${InstanceState}",
                "Tags": [${TagKeyValues}]
              }
            - Organizations: !Ref Organizations
              AccountIDs: !Ref AccountIDs
              EC2InstancesByID: !Ref EC2InstancesByID
              InstanceState: !Ref InstanceState
              TagKeyValues: !Ref TagKeyValues

  GuardDutyMalwareOnDemandScanSchedulerRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: scheduler.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: SchedulerPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
                - Effect: Allow
                  Action:
                    - lambda:InvokeFunction
                  Resource:
                    - !GetAtt GuardDutyMalwareOnDemandScanScheduledLambdaFunction.Arn

  GuardDutyMalwareOnDemandScheduledScanTopic:
    Type: AWS::SNS::Topic
    Properties:
      KmsMasterKeyId: alias/aws/sns

  GuardDutyMalwareOnDemandScheduledScanTopicPolicy:
    Type: AWS::SNS::TopicPolicy
    Properties:
      Topics:
        - !Ref GuardDutyMalwareOnDemandScheduledScanTopic
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              AWS: 
                - !GetAtt GuardDutyMalwareOnDemandScanScheduledLambdaExecutionRole.Arn
                - !GetAtt GuardDutyMalwareOnDemandScheduledNotificationLambdaExecutionRole.Arn
                - !GetAtt CheckMalwareScanLogGroupLambdaRole.Arn
            Action: sns:Publish
            Resource: !Ref GuardDutyMalwareOnDemandScheduledScanTopic

  GuardDutyMalwareOnDemandScanScheduledLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: LambdaBasicExecutionPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
                - Effect: Allow
                  Action:
                    - logs:CreateLogStream
                    - logs:PutLogEvents
                  Resource:
                    - !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/GuardDutyMalwareOnDemandScanScheduledLambdaFunction:*'
                - Effect: Allow
                  Action:
                    - logs:CreateLogGroup
                  Resource:
                    - !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/GuardDutyMalwareOnDemandScanScheduledLambdaFunction*'
                - Effect: Allow
                  Action:
                    - sns:Publish
                  Resource: !Ref 'GuardDutyMalwareOnDemandScheduledScanTopic'
                - Effect: Allow
                  Action:
                    - iam:GetRole
                  Resource: "arn:aws:iam::*:role/*AWSServiceRoleForAmazonGuardDutyMalwareProtection"
                - Effect: Allow
                  Action:
                    - guardduty:StartMalwareScan
                  Resource: "*"
                - Effect: Allow
                  Action:
                    - config:SelectAggregateResourceConfig
                  Resource:
                    - !Sub "arn:${AWS::Partition}:config:${ConfigAggregatorRegion}:${AWS::AccountId}:config-aggregator/*"
                - Effect: Allow
                  Action:
                    - config:DescribeConfigurationAggregators
                  Resource: "*"
                - Effect: Allow
                  Action: iam:CreateServiceLinkedRole
                  Resource: "*"
                  Condition:
                    StringLike:
                      "iam:AWSServiceName": "malware-protection.guardduty.amazonaws.com"

  GuardDutyMalwareOnDemandScanScheduledEventInvokeConfig:
    Type: AWS::Lambda::EventInvokeConfig
    Properties:
      FunctionName: !Ref GuardDutyMalwareOnDemandScanScheduledLambdaFunction
      MaximumRetryAttempts: 0
      Qualifier: "$LATEST"
  
  GuardDutyMalwareOnDemandScanScheduledLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      DeadLetterConfig:
        TargetArn: !Ref 'GuardDutyMalwareOnDemandScheduledScanTopic'
      FunctionName: GuardDutyMalwareOnDemandScanScheduledLambdaFunction
      Environment:
        Variables:
          SNStopicURL: !Ref 'GuardDutyMalwareOnDemandScheduledScanTopic'
          ConfigAggregatorName: !Ref 'ConfigAggregator'
          ConfigAggregatorRegion: !Ref 'ConfigAggregatorRegion'
      Runtime: python3.10
      Timeout: 900
      Handler: index.lambda_handler
      Role: !GetAtt GuardDutyMalwareOnDemandScanScheduledLambdaExecutionRole.Arn
      Code: 
        ZipFile: |
          import json
          import sys
          import os
          import datetime
          import boto3

          def lambda_handler(event, context):

              # Check Config Aggregator
              print ("Checking if the AWS Config Aggregator {0} exists in region {1}".format(os.environ['ConfigAggregatorName'],os.environ['ConfigAggregatorRegion']))
              check_aggregator()

              # Obtain list of EC2 instances
              query_state = select_state_filter(event["InstanceState"])
              all_instances = []

              # Instances passed manually as input
              if len(event["EC2InstancesID"]) != 0:
                  print ("Attempting to scan EC2 instances passed manually: "+str(event["EC2InstancesID"]))
                  manual_instances = get_manual_instances(event, event["EC2InstancesID"].replace(" ", "").split(","))
                  all_instances.extend(manual_instances)

              # Instances with tag input values 
              print ("Attempting to obtain EC2 Instances tagged with: "+str(event["Tags"]))
              tag_instances = get_instances_with_tags(event,query_state)
              all_instances.extend(tag_instances)

              # Scan EC2 Instances
              scan_instances([*set(all_instances)])


          def select_state_filter(instance_state):

              # Create query based on instance state paramater value passed in the Document

              query_state = ""

              if instance_state.lower() == "running":
                  query_state = "AND configuration.state.name = 'running'"

              elif instance_state.lower() == "stopped":
                  query_state = "AND configuration.state.name LIKE 'stop%'"

              elif instance_state.lower() == "both":
                  query_state = "AND (configuration.state.name LIKE 'stop%' OR configuration.state.name = 'running')"
              
              else:
                  error_subject = "On Demand Malware Scan Failed"
                  error_message = "EC2 Instance State value was not properly passed"
                  SNS_notification(error_message,error_subject)
                  print (error_message)
                  sys.exit()

              return query_state


          def get_manual_instances(event,instances):

              # Attempt to obtain EC2 manual instances
              resource_list = []
              try:
                  instancesquery = "('" + "','".join(instances) + "')"

                  # Query Organization
                  if event["Organizations"] == "true":
                      query = """
                          SELECT arn
                          WHERE resourceType = 'AWS::EC2::Instance'
                          AND awsRegion = '{region}'
                          AND resourceId IN {instancesquery}
                      """.format(region=os.environ['AWS_REGION'], instancesquery=instancesquery)

                  # Query specific account IDs
                  else:
                      if len(event["AccountIDs"]) == 0:
                          error_subject = "On Demand Malware Scan Failed"
                          error_message = "Organizations paramater value was set to false, and no account IDs values were provided. Review this selecting either Organizations paramater or provide Account IDs"
                          SNS_notification(error_message,error_subject)
                          print (error_message)
                          sys.exit()
                      else:
                          accountsquery = "('" + "','".join(account_IDs) + "')"

                          query = """
                              SELECT arn
                              WHERE resourceType = 'AWS::EC2::Instance'
                              AND accountId IN {accountsquery}
                              AND awsRegion = '{region}'
                              AND resourceId IN {instancesquery}
                          """.format(accountsquery=accountsquery, region=os.environ['AWS_REGION'], instancesquery=instancesquery)

                  # Perform Query in Config and fetch instances ARNs
                  query_response = config_advance_query(query)
                  for response in query_response:
                      results = (response["Results"])

                      if len(results) == 0:
                          message = str("EC2 Instance {1} could not be found with Config in region {0}".format(os.environ['AWS_REGION'],instance_id)) 
                          SNS_notification(message,"On Demand Malware Scan Failed")
                      else:
                          for result in results:
                              data = json.loads(result)
                              resource_list.append(data["arn"])


              except Exception as error:
                  SNS_notification(str(error),"On Demand Malware Scan Failed")

              return resource_list


          def get_instances_with_tags(event,query_state):

              # Attempt to obtain EC2 instances based on their tags and state

              resource_list = []
              tag_values = []

              for tags in event["Tags"]:
                  for key, value in tags.items():
                      tag_query = (key)+"="+(value)
                      tag_values.append(f"'{key}={value}'")

              # Construct query based on event parameters
              tag_conditions = ', '.join(tag_values)

              # Perform Query and Obtain EC2 instances ARNs
              try:
                  
                  # Query Organization
                  if event["Organizations"] == "true":
                      query = "SELECT arn \
                      WHERE resourceType = 'AWS::EC2::Instance' \
                      AND awsRegion = '{region}'\
                      {query_state} \
                      AND tags.tag IN ({tag_conditions})".format(region=os.environ['AWS_REGION'], query_state=query_state,tag_conditions=tag_conditions)
                  
                  # Query specific account IDs
                  else:

                      if len(event["AccountIDs"]) == 0:
                          error_subject = "On Demand Malware Scan Failed"
                          error_message = "Organizations paramater value was set to false, and no account IDs values were provided. Review this selecting either Organizations paramater or provide Account IDs"
                          SNS_notification(error_message,error_subject)
                          print (error_message)
                          sys.exit()
                      else:
                          account_IDs = event["AccountIDs"].split(",")

                      if len(account_IDs) == 1:
                          account_query = "({0})".format(account_IDs[0])
                      else:
                          account_query = tuple(account_IDs)
                          account_query = tuple(map(int, account_query))
                      
                      query = "SELECT arn \
                      WHERE resourceType = 'AWS::EC2::Instance' \
                      AND accountId IN {account_query}\
                      AND awsRegion = '{region}'\
                      {query_state} \
                      AND tags.tag IN ({tag_conditions})".format(account_query=account_query,region=os.environ['AWS_REGION'], query_state=query_state,tag_conditions=tag_conditions)

                  # Perform Query in Config and fetch instances ARNs
                  query_response = config_advance_query(query)
                  for response in query_response:
                      results = (response["Results"])
                      for result in results:
                          data = json.loads(result)
                          resource_list.append(data["arn"])

              except Exception as error:
                  SNS_notification(str(error),"On Demand Malware Scan Failed")

              return resource_list


          def check_aggregator():

              # Perform check upon Config Aggregator values passed

              try:
                  client = boto3.client('config', region_name=os.environ['ConfigAggregatorRegion'])
                  paginator = client.get_paginator('describe_configuration_aggregators')
                  response_iterator = paginator.paginate(ConfigurationAggregatorNames=[os.environ['ConfigAggregatorName']])

                  for response in response_iterator:
                      print (response["ConfigurationAggregators"])

              except Exception as error:
                  if "The configuration aggregator does not exist" in str(error):
                      error = "AWS config aggregator name {0} in region {1} could not be found. Review Aggregator Name and Region and redeploy".format(os.environ['ConfigAggregatorName'],os.environ['ConfigAggregatorRegion'])
                  print (error)
                  SNS_notification(str(error),"On Demand Malware Scan Failed")
                  sys.exit()


          def config_advance_query(query):

              # Perform Query in Config and fetch instances ARNs

              client = boto3.client('config', region_name=os.environ['ConfigAggregatorRegion'])
              paginator = client.get_paginator('select_aggregate_resource_config')
              response_iterator = paginator.paginate(Expression=query,ConfigurationAggregatorName=os.environ['ConfigAggregatorName'])

              return response_iterator


          def scan_instances(ec2_instances):

              # Attempt to scan EC2 instances
              
              scan_ids = []
              for ec2_instance in ec2_instances:
                  client = boto3.client('guardduty')

                  try:
                      response = client.start_malware_scan(ResourceArn=ec2_instance)
                      scan_id = (response["ScanId"])
                      scan_ids.append(scan_id)
                      print(f"Scan operation succeeded for instance {ec2_instance}")
                  except Exception as error:
                      error = str(error)
                      error_subject = "On Demand Malware Scan Failed"

                      # Handle error based on error message

                      if "A scan was initiated on this resource recently" in error:

                          # Instance scanned done during last hour

                          print (error)
                          error_message = str(error)\
                          +"\n"+" EC2 Instance: "+str(ec2_instance)
                          SNS_notification(error_message,error_subject)

                      elif "TooManyRequestsException" in error:

                          # TPS 1 per second. Client by default tries 5 retries. Implementing additional expontential back off

                          print(f"Too Many Requests Exception error for instance {ec2_instance}: {error}")

                          retry_count = 0
                          while retry_count < 5:
                              retry_count += 1
                              sleep_seconds = 2 ** retry_count
                              print(f"Retrying in {sleep_seconds} seconds for instance {ec2_instance}...")
                              time.sleep(sleep_seconds)

                              try:
                                  response = client.start_malware_scan(ResourceArn=ec2_instance)
                                  scan_id = (response["ScanId"])
                                  scan_ids.append(scan_id)
                                  print(f"Scan operation succeeded for instance {ec2_instance} after retry.")
                                  break

                              except Exception as error:
                                  error = str(error)
                                  if "TooManyRequestsException" in error:
                                      print(f"Too Many Requests Exception error on retry {retry_count} for instance {ec2_instance}: {error}")
                          
                          else:
                              print(f"Max retries reached for instance {ec2_instance}. Unable to perform the scan.")
                              error_message = "Unable to perform the scan. Max retries reached for instance: "+str(ec2_instance)
                              SNS_notification(error_message,"On Demand Malware Scan Failed")

                      else:
                          print (str(error))
                          error_message = str(error)\
                          +"\n"+" EC2 Instance: "+str(ec2_instance)
                          SNS_notification(str(error_message),str(error_subject))

              if len(scan_ids) == 0:
                  print ("No Instances found that could be scanned")
                  SNS_notification("No Instances found that could be scanned","On Demand Malware Scan finished")
              

          def SNS_notification(message, subject):

              # Send the SNS notification

              try:
                  sns = boto3.client('sns')
                  response_SNS = sns.publish(
                      TopicArn=os.environ["SNStopicURL"],
                      Message=str(message),
                      Subject=str(subject))
                  print('Sending SNS notification')
              except Exception as error:
                  print(error)

  GuardDutyMalwareOnDemandScheduledNotificationLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: LambdaBasicExecutionPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
                - Effect: Allow
                  Action:
                    - logs:CreateLogStream
                    - logs:PutLogEvents
                  Resource:
                    - !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/GuardDutyMalwareOnDemandScheduledNotificationLambdaFunction:*'
                - Effect: Allow
                  Action:
                    - logs:CreateLogGroup
                  Resource:
                    - !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/GuardDutyMalwareOnDemandScheduledNotificationLambdaFunction*'
                - Effect: Allow
                  Action:
                    - sns:Publish
                  Resource: !Ref 'GuardDutyMalwareOnDemandScheduledScanTopic'

  GuardDutyMalwareOnDemandScheduledNotificationEventInvokeConfig:
    Type: AWS::Lambda::EventInvokeConfig
    Properties:
      FunctionName: !Ref GuardDutyMalwareOnDemandScheduledNotificationLambdaFunction
      MaximumRetryAttempts: 0
      Qualifier: "$LATEST"
  
  GuardDutyMalwareOnDemandScheduledNotificationLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt GuardDutyMalwareOnDemandScheduledNotificationLambdaFunction.Arn
      Principal: logs.amazonaws.com
      SourceAccount: !Ref "AWS::AccountId"
      SourceArn: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/guardduty/malware-scan-events:*"
    DependsOn:
      - CheckMalwareScanLogGroupLambda
      
  GuardDutyMalwareOnDemandScheduledNotificationLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      DeadLetterConfig:
        TargetArn: !Ref 'GuardDutyMalwareOnDemandScheduledScanTopic'
      FunctionName: GuardDutyMalwareOnDemandScheduledNotificationLambdaFunction
      Environment:
        Variables:
          SNStopicURL: !Ref 'GuardDutyMalwareOnDemandScheduledScanTopic'
      Runtime: python3.10
      Timeout: 900
      Handler: index.lambda_handler
      Role: !GetAtt GuardDutyMalwareOnDemandScheduledNotificationLambdaExecutionRole.Arn
      Code: 
        ZipFile: |
          import json
          import os
          import boto3
          import gzip
          import json
          import base64

          def lambda_handler(event, context):

              # Obtain scan results and generate email notification.

              data = event['awslogs']['data']
              compressed_payload = base64.b64decode(data)
              uncompressed_payload = gzip.decompress(compressed_payload)
              events = json.loads(uncompressed_payload)
              log_events = events['logEvents']

              for log_event in log_events:
                  str_event = log_event["message"]
                  event = json.loads(str_event)
                  instance_id = event["resourceDetails"]["instanceDetails"]["instanceId"]
                  resource_details = event["resourceDetails"]
                  id_scan = event["scanRequestDetails"]["scanId"]
                  account_id = event["eventDetails"]["accountId"]

                  try:
                      if event["eventDetails"]["eventType"] == "EC2_SCAN_SKIPPED":
                          subject = "GuardDuty On Demand Malware Skipped - Scan ID: "+str(id_scan)
                          message = str("GuardDuty On Demand Malware Scan:"\
                              +"\n\nAccount ID: "+str(account_id)\
                              +"\nInstance ID: "+str(instance_id)\
                              +"\nResource Details: "+str(resource_details))

                          print ("Sending Notification for scan ID:" +str(id_scan))
                          SNS_notification(message, subject)

                      if event["eventDetails"]["eventType"] == "EC2_SCAN_COMPLETED":
                          status_result = event["scanResultsSummary"]["scanResultStatus"]
                          volumes_details = event["resourceDetails"]["instanceDetails"]["volumeDetailsList"]
                          total_gbytes = event["scanResultsSummary"]["scannedItemCount"]["totalGb"]
                          file_count = event["scanResultsSummary"]["scannedItemCount"]["files"]

                          subject = "GuardDuty On Demand Malware Completed - Scan ID: "+str(id_scan)
                          message = str("GuardDuty On Demand Malware Scan:"\
                              +"\n\nAccount ID: "+str(account_id)\
                              +"\nInstance ID: "+str(instance_id)\
                              +"\nStatus: "+str(status_result)\
                              +"\nTotal Gbytes: "+str(total_gbytes)\
                              +"\nFile Count: "+str(file_count)\
                              +"\nVolumes: "+str(volumes_details))
                              
                          print ("Sending Notification for scan ID:" +str(id_scan))
                          SNS_notification(message, subject)

                  except Exception as error:
                      error_subject = "Could not fetch Malware Scan data for the scan Id: "+str(id_scan)
                      error_message = "Error: "+str(error)
                      print (error_message)
                      SNS_notification(error_message,error_subject)


          def SNS_notification(message, subject):

              # Send the SNS notification

              try:
                  sns = boto3.client('sns')
                  sns_topic = os.environ["SNStopicURL"]
                  response_SNS = sns.publish(
                      TopicArn=os.environ["SNStopicURL"],
                      Message=str(message),
                      Subject=str(subject))
                  print('Sending SNS notification')
              except Exception as error:
                  print(error)

  CheckMalwareScanLogGroup:
      Type: Custom::CheckMalwareScanLogGroup
      Properties:
        ServiceToken:
          Fn::GetAtt:
            - CheckMalwareScanLogGroupLambda
            - Arn
  CheckMalwareScanLogGroupLambda:
    Type: AWS::Lambda::Function
    Properties:
      DeadLetterConfig:
        TargetArn: !Ref 'GuardDutyMalwareOnDemandScheduledScanTopic'
      Handler: index.lambda_handler
      Timeout: 60
      Role: !GetAtt CheckMalwareScanLogGroupLambdaRole.Arn
      Runtime: python3.10
      Code:
        ZipFile: |
          import boto3
          import cfnresponse

          def lambda_handler(event, context):
              try:
                  print(event)
                  request_type = event['RequestType']

                  if request_type == 'Create' or request_type == 'Update':
                      check_group_name_exists()
                      response_data = {'Status': 'SUCCESS'}
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)

                  else:
                      response_data = {'Status': 'SUCCESS'}
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)

              except Exception as e:
                  print(f"Error: {str(e)}")
                  response_data = {'Status': 'FAILED', 'Reason': str(e)}
                  cfnresponse.send(event, context, cfnresponse.FAILED, response_data)

          def check_group_name_exists():
              try:
                  # Initialize a Boto3 client for CloudWatch Logs
                  cloudwatch_logs_client = boto3.client('logs')

                  log_group_name = "/aws/guardduty/malware-scan-events"

                  # Use the describe_log_groups method to retrieve information about the log group
                  check_log_group = cloudwatch_logs_client.describe_log_groups(logGroupNamePrefix=log_group_name)
                  log_group_malware_scan_events = check_log_group["logGroups"]

                  if len(log_group_malware_scan_events) == 0:
                      # Create the log group
                      cloudwatch_logs_client.create_log_group(logGroupName=log_group_name)
                      print(f"CloudWatch Log Group {log_group_name} created")
                  else:
                      print(f"CloudWatch Log Group {log_group_name} already exists")

              except Exception as e:
                  # Handle exceptions
                  raise RuntimeError(f"Failed to check/create log group: {str(e)}")

  CheckMalwareScanLogGroupLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: LambdaBasicExecutionPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
                - Effect: Allow
                  Action:
                    - logs:CreateLogStream
                    - logs:PutLogEvents
                  Resource:
                    - !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*CheckMalwareScanLogGroupLambda*:*'
                - Effect: Allow
                  Action:
                    - logs:CreateLogGroup
                  Resource:
                    - !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*CheckMalwareScanLogGroupLambda*'
                - Effect: Allow
                  Action:
                    - logs:DescribeLogGroups
                  Resource:
                    - !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:*'
                - Effect: Allow
                  Action:
                    - logs:CreateLogGroup
                  Resource:
                    - !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/guardduty/malware-scan-events*'
                - Effect: Allow
                  Action:
                    - sns:Publish
                  Resource: !Ref 'GuardDutyMalwareOnDemandScheduledScanTopic'

  SubscriptionFilter: 
    Type: AWS::Logs::SubscriptionFilter
    Properties: 
      LogGroupName: "/aws/guardduty/malware-scan-events"
      FilterName: "OnDemandScanScheduledFilter"
      FilterPattern: "{$.scanRequestDetails.requestType = ON_DEMAND && ($.eventDetails.eventType = EC2_SCAN_SKIPPED) || ($.eventDetails.eventType = EC2_SCAN_COMPLETED)}"
      DestinationArn: !GetAtt "GuardDutyMalwareOnDemandScheduledNotificationLambdaFunction.Arn"
    DependsOn:
      - CheckMalwareScanLogGroupLambda
      - GuardDutyMalwareOnDemandScheduledNotificationLambdaFunction

Outputs:
  SchedulerLink:
    Description: "Scheduler for GuardDuty On-demand malware scan"
    Value: !Sub 'https://console.aws.amazon.com/scheduler/home?region=${AWS::Region}#schedules/default/GuardDutyMalwareOnDemandScheduledEvent'

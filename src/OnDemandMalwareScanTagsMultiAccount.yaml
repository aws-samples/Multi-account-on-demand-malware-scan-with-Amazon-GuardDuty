---
AWSTemplateFormatVersion: 2010-09-09
Description: '**WARNING** This template creates SSM Automation Document, Lambda
  Functions, SNS Topic, CloudWatch Logs subscription filter, EC2 resources and related resources. You will be billed for the AWS resources
  used if you create a stack from this template.'

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: On Demand Malware Scan Sample Tester - Amazon EC2 Configuration
        Parameters:
          - CreateMalwareTester
          - LatestLinuxAMI
          - TagKey
          - TagValue
      - Label:
          default: AWS Config Parameters
        Parameters:
          - ConfigAggregator
          - ConfigAggregatorRegion

    ParameterLabels:
      CreateMalwareTester:
        default: Create On Demand Malware Scan Sample Tester Condition
      LatestLinuxAMI:
        default: Latest Amazon Linux Instance used for Tester
      TagKey:
        default: 'Tag Key'
      TagValue:
        default: 'Tag Value'
      InstanceState:
        default: 'The following value will allow to filter what EC2 Instances are to be scanned based on their state'
      ConfigAggregator:
        default: Config Aggregator Name
      ConfigAggregatorRegion:
        default: Config Aggregator Region 

Parameters:
  CreateMalwareTester:
    Description: "'True' will generate On Demand Malware Scan Sample Tester resources. 'False' will skipped them"
    Type: String
    Default: "False"
    AllowedValues:
      - "True"
      - "False"
  TagKey:
    Type: String
    Description: 'Input the tag key for the On Demand Malware test instances'
  TagValue:
    Type: String
    Description: 'Input the tag value for the On Demand Malware test instances'
  LatestLinuxAMI:
    Type: 'AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>'
    Default: /aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2
  ConfigAggregator:
    Type: String
    Description: Input the Aggregator name
  ConfigAggregatorRegion:
    Type: String
    Description: Input the Aggregator Region
    Default: "us-east-1"
    AllowedValues:
      - "us-east-1"
      - "us-east-2"
      - "us-west-1"
      - "us-west-2"
      - "af-south-1"
      - "ap-east-1"
      - "ap-south-2"
      - "ap-southeast-3"
      - "ap-southeast-4"
      - "ap-south-1"
      - "ap-northeast-3"
      - "ap-northeast-2"
      - "ap-southeast-1"
      - "ap-southeast-2"
      - "ap-northeast-1"
      - "ca-central-1"
      - "eu-central-1"
      - "eu-west-1"
      - "eu-west-2"
      - "eu-south-1"
      - "eu-west-3"
      - "eu-south-2"
      - "eu-north-1"
      - "eu-central-2"
      - "il-central-1"
      - "me-south-1"
      - "me-central-1"
      - "sa-east-1"
      - "ca-west-1"

Conditions:
  IsTrue: !Equals [!Ref CreateMalwareTester, 'True']

Resources:
  VPC:
    Type: AWS::EC2::VPC
    Condition: IsTrue
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsSupport: true
      EnableDnsHostnames: true
      InstanceTenancy: default
      Tags:
        - Key: Name
          Value: On Demand Malware Scan Sample Tester
  
  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Condition: IsTrue
    Properties:
      Tags:
      - Key: Name
        Value: On Demand Malware Scan Sample Tester

  InternetGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Condition: IsTrue
    Properties:
      VpcId: !Ref VPC
      InternetGatewayId: !Ref InternetGateway

  PublicSubnet:
    Type: AWS::EC2::Subnet
    Condition: IsTrue
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.0.0/24
      Tags:
      - Key: Name
        Value: Public Subnet On Demand Malware Scan Sample Tester

  PrivateSubnet:
    Type: AWS::EC2::Subnet
    Condition: IsTrue
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.1.0/24
      Tags:
      - Key: Name
        Value: Private Subnet On Demand Malware Scan Sample Tester

  PublicRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Condition: IsTrue
    Properties:
      SubnetId: !Ref PublicSubnet
      RouteTableId: !Ref PublicRouteTable

  PrivateRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Condition: IsTrue
    Properties:
      SubnetId: !Ref PrivateSubnet
      RouteTableId: !Ref PrivateRouteTable

  NatGatewayEIP:
    Type: AWS::EC2::EIP
    Condition: IsTrue
    Properties:
      Domain: vpc
      Tags:
      - Key: Name
        Value: On Demand Malware Scan Sample Tester

  NatGateway:
    Type: AWS::EC2::NatGateway
    Condition: IsTrue
    Properties:
      AllocationId: !GetAtt NatGatewayEIP.AllocationId
      SubnetId: !Ref PublicSubnet
      Tags:
      - Key: Name
        Value: On Demand Malware Scan Sample Tester

  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Condition: IsTrue
    Properties:
      VpcId: !Ref VPC
      Tags:
      - Key: Name
        Value: Public

  PublicRoute:
    Type: AWS::EC2::Route
    Condition: IsTrue
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway

  PrivateRouteTable:
    Type: AWS::EC2::RouteTable
    Condition: IsTrue
    Properties:
      VpcId: !Ref VPC
      Tags:
      - Key: Name
        Value: Private

  PrivateRoute:
    Type: AWS::EC2::Route
    Condition: IsTrue
    Properties:
      RouteTableId: !Ref PrivateRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !GetAtt NatGateway.NatGatewayId

  NatInstanceSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Condition: IsTrue
    Properties:
      GroupDescription: Security group for NAT instance
      VpcId: !Ref VPC
      SecurityGroupEgress:
        - 
          Description: Egress Rule for for NAT instance
          IpProtocol: -1
          CidrIp: 0.0.0.0/0
      Tags:
      - Key: Name
        Value: NAT On Demand Malware Scan Sample Tester

  PrivateInstanceSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Condition: IsTrue
    Properties:
      GroupDescription: Security group for private instance
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - 
          Description: Ingress Rule for for private instance
          IpProtocol: -1
          SourceSecurityGroupId: !Ref NatInstanceSecurityGroup
      SecurityGroupEgress:
        - 
          Description: Egress Rule for for private instance
          IpProtocol: -1
          CidrIp: 0.0.0.0/0
      Tags:
      - Key: Name
        Value: Private Instance On Demand Malware Scan Sample Tester

  InstanceMalwareEicarSample:
    Type: 'AWS::EC2::Instance'
    Condition: IsTrue
    Properties:
      ImageId: !Ref LatestLinuxAMI
      InstanceType: t3.micro
      SubnetId: !Ref PrivateSubnet
      SecurityGroupIds:
        - Ref: PrivateInstanceSecurityGroup
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          yum install -y wget  # Install wget
          wget -O /home/ec2-user/eicar.com.txt https://secure.eicar.org/eicar.com.txt
          chown ec2-user:ec2-user /home/ec2-user/eicar.com.txt
      Tags:
        - Key: Name
          Value: OnDemandMalwareEicarSample
        - Key: !Ref TagKey
          Value: !Ref TagValue

  InstanceMalwareClean:
    Type: 'AWS::EC2::Instance'
    Condition: IsTrue
    Properties:
      ImageId: !Ref LatestLinuxAMI
      InstanceType: t3.micro
      SubnetId: !Ref PrivateSubnet
      SecurityGroupIds:
        - !Ref PrivateInstanceSecurityGroup
      Tags:
        - Key: Name
          Value: OnDemandMalwareClean
        - Key: !Ref TagKey
          Value: !Ref TagValue
  
  GuardDutyMalwareOnDemandScanTopic:
    Type: AWS::SNS::Topic
    Properties:
      KmsMasterKeyId: alias/aws/sns

  GuardDutyMalwareOnDemandScanTopicPolicy:
    Type: AWS::SNS::TopicPolicy
    Properties:
      Topics:
        - !Ref GuardDutyMalwareOnDemandScanTopic
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              AWS: 
                - !GetAtt GuardDutyMalwareOnDemandScanLambdaExecutionRole.Arn
                - !GetAtt GuardDutyMalwareOnDemandNotificationLambdaExecutionRole.Arn
                - !GetAtt CheckMalwareScanLogGroupLambdaRole.Arn
            Action: sns:Publish
            Resource: !Ref GuardDutyMalwareOnDemandScanTopic

  GuardDutyMalwareOnDemandScanSSMDocument:
    Type: AWS::SSM::Document
    Properties:
      Name: GuardDutyMalwareOnDemandScan
      DocumentType: Automation
      Content:
        description: |
          1. Organizations:
          Insert **`true`** or **`false`** to obtain EC2 instances from ther entire Organizations
          2. Accounts IDs:
          If you selected **`false`** in point **1**, insert accounts IDs from where to obtain EC2 instances. Values need to be separated by a comma e.g: `AccountID1`, `AccountID2`, `AccountID3`, `AccountID4`
          3. Tag key / Tag Value:
          Insert Tag Key and Tag Value to obtain the EC2 instances
          4. EC2 Instances state:
          - Insert **RUNNING`** to scan EC2 instances in state 'running' 
          - Insert **STOPPED`** to scan EC2 instances in states 'stopping', 'stopped'
          - Insert **BOTH`** to scan EC2 instances in all previous mentioned states 
        schemaVersion: "0.3"
        parameters:
          TagKey:
            type: String
            description: Tag Key for resources tagged with it along with the Tag value
          TagValue:
            type: String
            description: Tag value for resources tagged with it along with the Tag key
          InstanceState:
            type: String
            description: EC2 instances state to be scanned. Insert one of the following values RUNNING, STOPPED or BOTH
            default: 'RUNNING'
            allowedValues:
              - 'RUNNING'
              - 'STOPPED'
              - 'BOTH'
          Organizations:
            type: Boolean
            default: true
            allowedValues:
              - 'true'
              - 'false'
            description: Set to "true" if the scan should be performed acrross all your accounts in Organizations
          AccountIDs:
            type: StringList
            default:
              - ''
            description: Insert accounts IDs separated by comma where to scan your resources if the Organizations is set to false
        mainSteps:
          - name: InvokeOnDemandScan
            action: 'aws:invokeLambdaFunction'
            inputs:
              InvocationType: RequestResponse
              FunctionName: !Ref GuardDutyMalwareOnDemandScanLambdaFunction
              InputPayload:
                TagKey: '{{TagKey}}'
                TagValue: '{{TagValue}}'
                InstanceState: '{{InstanceState}}'
                Organizations: '{{Organizations}}'
                AccountIDs: '{{AccountIDs}}'
                
  GuardDutyMalwareOnDemandScanLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: LambdaBasicExecutionPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
                - Effect: Allow
                  Action:
                    - logs:CreateLogStream
                    - logs:PutLogEvents
                  Resource:
                    - !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/GuardDutyMalwareOnDemandScanLambdaFunction:*'
                - Effect: Allow
                  Action:
                    - logs:CreateLogGroup
                  Resource:
                    - !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/GuardDutyMalwareOnDemandScanLambdaFunction*'
                - Effect: Allow
                  Action:
                    - sns:Publish
                  Resource: !Ref 'GuardDutyMalwareOnDemandScanTopic'
                - Effect: Allow
                  Action:
                    - guardduty:StartMalwareScan
                  Resource: "*"
                - Effect: Allow
                  Action:
                    - config:SelectAggregateResourceConfig
                  Resource: 
                    - !Sub "arn:${AWS::Partition}:config:${ConfigAggregatorRegion}:${AWS::AccountId}:config-aggregator/*"
                - Effect: Allow
                  Action:
                    - config:DescribeConfigurationAggregators
                  Resource: "*"
                - Effect: Allow
                  Action: iam:CreateServiceLinkedRole
                  Resource: "*"
                  Condition:
                    StringLike:
                      "iam:AWSServiceName": "malware-protection.guardduty.amazonaws.com"
                - Effect: Allow
                  Action:
                    - iam:GetRole
                  Resource: "arn:aws:iam::*:role/*AWSServiceRoleForAmazonGuardDutyMalwareProtection"

  GuardDutyMalwareOnDemandScanEventInvokeConfig:
    Type: AWS::Lambda::EventInvokeConfig
    Properties:
      FunctionName: !Ref GuardDutyMalwareOnDemandScanLambdaFunction
      MaximumRetryAttempts: 0
      Qualifier: "$LATEST"
  
  GuardDutyMalwareOnDemandScanLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: GuardDutyMalwareOnDemandScanLambdaFunction
      Environment:
        Variables:
          SNStopicURL: !Ref 'GuardDutyMalwareOnDemandScanTopic'
          ConfigAggregatorName: !Ref 'ConfigAggregator'
          ConfigAggregatorRegion: !Ref 'ConfigAggregatorRegion'
      Runtime: python3.10
      Timeout: 900
      Handler: index.lambda_handler
      Role: !GetAtt GuardDutyMalwareOnDemandScanLambdaExecutionRole.Arn
      Code: 
        ZipFile: |
          import json
          import sys
          import os
          import time
          import boto3

          def lambda_handler(event, context):

              # Check Config Aggregator
              print ("Checking if the AWS Config Aggregator {0} exists in region {1}".format(os.environ['ConfigAggregatorName'],os.environ['ConfigAggregatorRegion']))
              check_aggregator()

              # Obtain list of EC2 instances
              query_state = select_state_filter(event["InstanceState"])
              all_instances = []

              print ("Attempting to obtain EC2 Instances tagged with: "+str(event["TagKey"]+":"+event["TagValue"]))
              instances_with_tags = get_instances_with_tags(event, query_state)
              all_instances.extend(instances_with_tags)

              # Scan EC2 Instances
              scan_instances([*set(all_instances)])


          def select_state_filter(instance_state):

              # Create query based on instance state paramater value passed in the Document

              query_state = ""

              if instance_state.lower() == "running":
                  query_state = "AND configuration.state.name = 'running'"

              elif instance_state.lower() == "stopped":
                  query_state = "AND configuration.state.name LIKE 'stop%'"

              elif instance_state.lower() == "both":
                  query_state = "AND (configuration.state.name LIKE 'stop%' OR configuration.state.name = 'running')"

              else:
                  error_subject = "On Demand Malware Scan Failed"
                  error_message = "EC2 Instance State value was not properly passed"
                  SNS_notification(error_message,error_subject)
                  print (error_message)
                  sys.exit()
              
              return query_state


          def get_instances_with_tags(event,query_state):

              # Attempt to obtain EC2 instances based on their tags and state

              resource_list = []
              tag_query = (event["TagKey"])+"="+(event["TagValue"])

              # Perform Query and Obtain EC2 instances ARNs
              try:

                  # Query the Organization
                  if event["Organizations"] == True:
                      query = "SELECT arn \
                      WHERE resourceType = 'AWS::EC2::Instance' \
                      AND awsRegion = '{region}'\
                      {query_state} \
                      AND tags.tag = '{tag_query}'".format(region=os.environ['AWS_REGION'],query_state=query_state,tag_query=tag_query)

                  # Query specific account IDs
                  else:
                      if len(event["AccountIDs"][0]) == 0:
                          error_subject = "On Demand Malware Scan Failed"
                          error_message = "Organizations paramater value was set to false, and no account IDs values were provided. Review this selecting either Organizations paramater or provide Account IDs"
                          SNS_notification(error_message,error_subject)
                          print (error_message)
                          sys.exit()

                      if len(event["AccountIDs"]) == 1:
                          account_query = "({0})".format(event["AccountIDs"][0])
                      else:
                          account_query = tuple(event["AccountIDs"])
                          account_query = tuple(map(int, account_query))
                      
                      query = "SELECT arn \
                      WHERE resourceType = 'AWS::EC2::Instance' \
                      AND accountId IN {account_query}\
                      AND awsRegion = '{region}'\
                      {query_state} \
                      AND tags.tag = '{tag_query}'".format(account_query=account_query,region=os.environ['AWS_REGION'],query_state=query_state,tag_query=tag_query)

                  # Perform Query in Config and fetch instances ARNs
                  query_response = config_advance_query(query)
                  for response in query_response:
                      results = (response["Results"])
                      for result in results:
                          data = json.loads(result)
                          resource_list.append(data["arn"])

              except Exception as error:
                  print (error)
                  SNS_notification(str(error),"On Demand Malware Scan Failed")

              return resource_list


          def check_aggregator():

              # Perform check upon Config Aggregator values passed

              try:
                  client = boto3.client('config', region_name=os.environ['ConfigAggregatorRegion'])
                  paginator = client.get_paginator('describe_configuration_aggregators')
                  response_iterator = paginator.paginate(ConfigurationAggregatorNames=[os.environ['ConfigAggregatorName']])

                  for response in response_iterator:
                      print (response["ConfigurationAggregators"])

              except Exception as error:
                  if "The configuration aggregator does not exist" in str(error):
                      error = "AWS config aggregator name {0} in region {1} could not be found. Review Aggregator Name and Region and redeploy".format(os.environ['ConfigAggregatorName'],os.environ['ConfigAggregatorRegion'])
                  print (error)
                  SNS_notification(str(error),"On Demand Malware Scan Failed")
                  sys.exit()


          def config_advance_query(query):

              # Perform Query in Config and fetch instances ARNs

              client = boto3.client('config', region_name=os.environ['ConfigAggregatorRegion'])
              paginator = client.get_paginator('select_aggregate_resource_config')
              response_iterator = paginator.paginate(Expression=query,ConfigurationAggregatorName=os.environ['ConfigAggregatorName'])

              return response_iterator


          def scan_instances(ec2_instances):

              # Attempt to scan EC2 instances
              
              scan_ids = []
              for ec2_instance in ec2_instances:
                  client = boto3.client('guardduty')

                  try:
                      response = client.start_malware_scan(ResourceArn=ec2_instance)
                      scan_id = (response["ScanId"])
                      scan_ids.append(scan_id)
                      print(f"Scan operation succeeded for instance {ec2_instance}")
                  except Exception as error:
                      error = str(error)
                      error_subject = "On Demand Malware Scan Failed"

                      # Handle error based on error message

                      if "A scan was initiated on this resource recently" in error:

                          # Instance scanned done during last hour

                          print (error)
                          error_message = str(error)\
                          +"\n"+" EC2 Instance: "+str(ec2_instance)
                          SNS_notification(error_message,error_subject)

                      elif "TooManyRequestsException" in error:

                          # TPS 1 per second. Client by default tries 5 retries. Implementing additional expontential back off

                          print(f"Too Many Requests Exception error for instance {ec2_instance}: {error}")

                          retry_count = 0
                          while retry_count < 5:
                              retry_count += 1
                              sleep_seconds = 2 ** retry_count
                              print(f"Retrying in {sleep_seconds} seconds for instance {ec2_instance}...")
                              time.sleep(sleep_seconds)

                              try:
                                  response = client.start_malware_scan(ResourceArn=ec2_instance)
                                  scan_id = (response["ScanId"])
                                  scan_ids.append(scan_id)
                                  print(f"Scan operation succeeded for instance {ec2_instance} after retry.")
                                  break

                              except Exception as error:
                                  error = str(error)
                                  if "TooManyRequestsException" in error:
                                      print(f"Too Many Requests Exception error on retry {retry_count} for instance {ec2_instance}: {error}")
                          
                          else:
                              print(f"Max retries reached for instance {ec2_instance}. Unable to perform the scan.")
                              error_message = "Unable to perform the scan. Max retries reached for instance: "+str(ec2_instance)
                              SNS_notification(error_message,"On Demand Malware Scan Failed")

                      else:
                          print (str(error))
                          error_message = str(error)\
                          +"\n"+" EC2 Instance: "+str(ec2_instance)
                          SNS_notification(str(error_message),str(error_subject))

              if len(scan_ids) == 0:
                  print ("No Instances found that could be scanned")
                  SNS_notification("No Instances found that could be scanned","On Demand Malware Scan finished")
              

          def SNS_notification(message, subject):

              # Send the SNS notification

              try:
                  sns = boto3.client('sns')
                  response_SNS = sns.publish(
                      TopicArn=os.environ["SNStopicURL"],
                      Message=str(message),
                      Subject=str(subject))
                  print('Sending SNS notification')
              except Exception as error:
                  print(error)

  GuardDutyMalwareOnDemandNotificationLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: LambdaBasicExecutionPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
                - Effect: Allow
                  Action:
                    - logs:CreateLogStream
                    - logs:PutLogEvents
                  Resource:
                    - !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/GuardDutyMalwareOnDemandNotificationLambda:*'
                - Effect: Allow
                  Action:
                    - logs:CreateLogGroup
                  Resource:
                    - !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/GuardDutyMalwareOnDemandNotificationLambda*'
                - Effect: Allow
                  Action:
                    - sns:Publish
                  Resource: !Ref 'GuardDutyMalwareOnDemandScanTopic'

  GuardDutyMalwareOnDemandNotificationScanEventInvokeConfig:
    Type: AWS::Lambda::EventInvokeConfig
    Properties:
      FunctionName: !Ref GuardDutyMalwareOnDemandNotificationLambda
      MaximumRetryAttempts: 0
      Qualifier: "$LATEST"
    
  GuardDutyMalwareOnDemandNotificationScanLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt GuardDutyMalwareOnDemandNotificationLambda.Arn
      Principal: logs.amazonaws.com
      SourceAccount: !Ref "AWS::AccountId"
      SourceArn: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/guardduty/malware-scan-events:*"
    DependsOn:
      - CheckMalwareScanLogGroupLambda

  GuardDutyMalwareOnDemandNotificationLambda:
    Type: AWS::Lambda::Function
    Properties:
      DeadLetterConfig:
        TargetArn: !Ref 'GuardDutyMalwareOnDemandScanTopic'
      FunctionName: GuardDutyMalwareOnDemandNotificationLambda
      Environment:
        Variables:
          SNStopicURL: !Ref 'GuardDutyMalwareOnDemandScanTopic'
      Runtime: python3.10
      Timeout: 900
      Handler: index.lambda_handler
      Role: !GetAtt GuardDutyMalwareOnDemandNotificationLambdaExecutionRole.Arn
      Code: 
        ZipFile: |
          import json
          import os
          import boto3
          import gzip
          import json
          import base64

          def lambda_handler(event, context):

              # Obtain scan results and generate email notification.

              data = event['awslogs']['data']
              compressed_payload = base64.b64decode(data)
              uncompressed_payload = gzip.decompress(compressed_payload)
              events = json.loads(uncompressed_payload)
              log_events = events['logEvents']

              for log_event in log_events:
                  str_event = log_event["message"]
                  event = json.loads(str_event)
                  instance_id = event["resourceDetails"]["instanceDetails"]["instanceId"]
                  resource_details = event["resourceDetails"]
                  id_scan = event["scanRequestDetails"]["scanId"]
                  account_id = event["eventDetails"]["accountId"]

                  try:
                      if event["eventDetails"]["eventType"] == "EC2_SCAN_SKIPPED":
                          subject = "GuardDuty On Demand Malware Skipped - Scan ID: "+str(id_scan)
                          message = str("GuardDuty On Demand Malware Scan:"\
                              +"\n\nAccount ID: "+str(account_id)\
                              +"\nInstance ID: "+str(instance_id)\
                              +"\nResource Details: "+str(resource_details))

                          print ("Sending Notification for scan ID:" +str(id_scan))
                          SNS_notification(message, subject)

                      if event["eventDetails"]["eventType"] == "EC2_SCAN_COMPLETED":
                          status_result = event["scanResultsSummary"]["scanResultStatus"]
                          volumes_details = event["resourceDetails"]["instanceDetails"]["volumeDetailsList"]
                          total_gbytes = event["scanResultsSummary"]["scannedItemCount"]["totalGb"]
                          file_count = event["scanResultsSummary"]["scannedItemCount"]["files"]

                          subject = "GuardDuty On Demand Malware Completed - Scan ID: "+str(id_scan)
                          message = str("GuardDuty On Demand Malware Scan:"\
                              +"\n\nAccount ID: "+str(account_id)\
                              +"\nInstance ID: "+str(instance_id)\
                              +"\nStatus: "+str(status_result)\
                              +"\nTotal Gbytes: "+str(total_gbytes)\
                              +"\nFile Count: "+str(file_count)\
                              +"\nVolumes: "+str(volumes_details))
                              
                          print ("Sending Notification for scan ID:" +str(id_scan))
                          SNS_notification(message, subject)

                  except Exception as error:
                      error_subject = "Could not fetch Malware Scan data for the scan Id: "+str(id_scan)
                      error_message = "Error: "+str(error)
                      print (error_message)
                      SNS_notification(error_message,error_subject)


          def SNS_notification(message, subject):

              # Send the SNS notification

              try:
                  sns = boto3.client('sns')
                  response_SNS = sns.publish(
                      TopicArn=os.environ["SNStopicURL"],
                      Message=str(message),
                      Subject=str(subject))
                  print('Sending SNS notification')
              except Exception as error:
                  print(error)

  CheckMalwareScanLogGroup:
      Type: Custom::CheckMalwareScanLogGroup
      Properties:
        ServiceToken:
          Fn::GetAtt:
            - CheckMalwareScanLogGroupLambda
            - Arn
  CheckMalwareScanLogGroupLambda:
    Type: AWS::Lambda::Function
    Properties:
      DeadLetterConfig:
        TargetArn: !Ref 'GuardDutyMalwareOnDemandScanTopic'
      Handler: index.lambda_handler
      Timeout: 60
      Role: !GetAtt CheckMalwareScanLogGroupLambdaRole.Arn
      Runtime: python3.10
      Code:
        ZipFile: |
          import boto3
          import cfnresponse

          def lambda_handler(event, context):
              try:
                  print(event)
                  request_type = event['RequestType']

                  if request_type == 'Create' or request_type == 'Update':
                      check_group_name_exists()
                      response_data = {'Status': 'SUCCESS'}
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)

                  else:
                      response_data = {'Status': 'SUCCESS'}
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)

              except Exception as e:
                  print(f"Error: {str(e)}")
                  response_data = {'Status': 'FAILED', 'Reason': str(e)}
                  cfnresponse.send(event, context, cfnresponse.FAILED, response_data)

          def check_group_name_exists():
              try:
                  # Initialize a Boto3 client for CloudWatch Logs
                  cloudwatch_logs_client = boto3.client('logs')

                  log_group_name = "/aws/guardduty/malware-scan-events"

                  # Use the describe_log_groups method to retrieve information about the log group
                  check_log_group = cloudwatch_logs_client.describe_log_groups(logGroupNamePrefix=log_group_name)
                  log_group_malware_scan_events = check_log_group["logGroups"]

                  if len(log_group_malware_scan_events) == 0:
                      # Create the log group
                      cloudwatch_logs_client.create_log_group(logGroupName=log_group_name)
                      print(f"CloudWatch Log Group {log_group_name} created")
                  else:
                      print(f"CloudWatch Log Group {log_group_name} already exists")

              except Exception as e:
                  # Handle exceptions
                  raise RuntimeError(f"Failed to check/create log group: {str(e)}")

  CheckMalwareScanLogGroupLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: LambdaBasicExecutionPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
                - Effect: Allow
                  Action:
                    - logs:CreateLogStream
                    - logs:PutLogEvents
                  Resource:
                    - !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*CheckMalwareScanLogGroupLambda*:*'
                - Effect: Allow
                  Action:
                    - logs:CreateLogGroup
                  Resource:
                    - !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*CheckMalwareScanLogGroupLambda*'
                - Effect: Allow
                  Action:
                    - logs:DescribeLogGroups
                  Resource:
                    - !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:*'
                - Effect: Allow
                  Action:
                    - logs:CreateLogGroup
                  Resource:
                    - !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/guardduty/malware-scan-events*'
                - Effect: Allow
                  Action:
                    - sns:Publish
                  Resource: !Ref 'GuardDutyMalwareOnDemandScanTopic'

  SubscriptionFilter: 
    Type: AWS::Logs::SubscriptionFilter
    Properties: 
      LogGroupName: "/aws/guardduty/malware-scan-events"
      FilterName: "OnDemandScanSSMDocumentFilter"
      FilterPattern: "{$.scanRequestDetails.requestType = ON_DEMAND && ($.eventDetails.eventType = EC2_SCAN_SKIPPED) || ($.eventDetails.eventType = EC2_SCAN_COMPLETED)}"
      DestinationArn: !GetAtt "GuardDutyMalwareOnDemandNotificationLambda.Arn"
    DependsOn:
      - CheckMalwareScanLogGroupLambda
      - GuardDutyMalwareOnDemandNotificationScanLambdaPermission

Outputs:
  DocumentLink:
    Description: "SSM document for GuardDuty On-demand malware scan"
    Value: !Sub 'https://console.aws.amazon.com/systems-manager/documents/GuardDutyMalwareOnDemandScan/description?region=${AWS::Region}'

